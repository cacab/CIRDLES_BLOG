---
layout: default
---
<body>
  
<h3>Blog Post #5 Docker and Kubernetes- Possibility For User Sessions 5.26.2020</h3>
<p>This past Friday, I had the pleasure of attending a webinar hosted by Brent Lastner and Open Source 101. This webinar focused on the use of Docker and Kubernetes and their basics. In short, Docker is a platform-as-a-service product that uses images, which are made of layers which are generated from the Docker file. Multiple containers can share access to the same underlying image, which is a convenient tool that allows for reusability. </p>
<p></p>
<p>Kubernetes is a container orchestration system, which automates application management and deployment. In Friday’s webinar, Brent gave the example of Kubernetes being the equivalent to the cargo ship which houses Docker’s containers. </p>
<p></p>
<p>While the functionality of Docker can be limited when Docker Enterprise isn’t used, the use of Kubernetes with NGINX and Docker’s open source version to create sticky sessions. It is possible to use these architectures together to implement cookies. </p>
<p></p>
</div>
  
      <h3>Blog Post #4 Solution to CORS Error: SQUID Web Part 2 5.21.2020</h3>
<p>In Chrome, upon attempting to upload Prawn and Task files, the following error is generated:</p>
<p>Access to XMLHttpRequest at 'http://cirdles.cs.cofc.edu/Services/squidReporting' from origin 'http://localhost:8080' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. </p>
<p>CORS stands for cross-origin resource sharing and allows for cross-domain communication from the browser. The current issue is that somewhere within SQUID’s architecture, CORS is not enabled. </p>
<p>Currently, the CORS error can be mitigated by the use of a browser plugin. </p>
<p></p>
<p>The following items have been implemented in an attempt to eliminate the error and the use of a browser plugin: </p>
<p></p>
<p>Enabling CORS in NGINX by using add_header Access-Control-Allow-Origin *;</p>
<p></p>
<p>Enabling CORS in Tomcat by using filter mapping. </p>
<p></p>
<p>Potential further items:</p>
<p>Research effective security practices to use when enabling CORS</p>
<p>Research the possibility of enabling CORS at the web application level in routes or servlets. </p>
<p>Research additional server configurations </p>

  
  
  <br>
    <h3>Blog Post #3 Solution to CORS Error: SQUID Web Part 1 5.18.2020</h3>
<p>This post discusses the debugging of SQUID Web, running locally. </p>
<p></p>
<p>In Chrome, upon attempting to upload Prawn and Task files, the following error is generated: </p>
<p></p>
<p>Access to XMLHttpRequest at 'http://cirdles.cs.cofc.edu/Services/squidReporting' from origin 'http://localhost:8080' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.</p>
<p></p>
<p>The following items fix this error: </p>
<p></p>
<p>In /usr/local/etc/nginx/nginx.conf, change the port from 80 to 8080. </p>
<p></p>
<p>In Squid/index.js, change the endpoint to https://cirdles.cs.cofc.edu/Services/squidReporting. </p>
<p></p>
<p>In Chrome, unblock CORS by a method of your choosing, such as CORS Unblock. </p>
<p></p>
<p>My next blog post will explore how to unblock CORS without using a plugin. </p>
<p></p>
  
   <br> 
  <h3>Blog Post #2 Troubleshooting SQUID Architecture Locally 5.14.2020</h3>
<p>Before beginning the process of building on to the current functionality of SQUID Web, an issue must be addressed within the application where the client-side server and the backend server are facing connectivity issues. The client-side of SQUID Web uses NGINX, while the backend uses Tomcat. Thus, a reverse proxy exists where redirection takes place from NGINX to Tomcat. Currently, something is blocked, preventing these two servers from connecting. This blog post will discuss this troubleshooting process. Here is a list of some of the commands used in this process: </p>
<p></p>
<p>Tomcat Commands: </p>
<p> </p>
<p>Start / Shutdown TomCat: </p>
<p>cd /Users/caitlin/apache-tomcat-9.0.34/bin </p>
<p>./startup.sh </p>
<p>OR</p>
<p>./shutdown.sh </p>
<p> </p>
<p>Stop Tomcat: </p>
<p>Tomcat config: </p>
<p>Users/caitlin/apache-tomcat-9.0.34/server.xml</p>
<p> </p>
<p>NGINX Commands: </p>
<p> </p>
<p>Opens config file: </p>
<p>nano /usr/local/etc/nginx/nginx.conf</p>
<p> </p>
<p>Or use </p>
<p>/usr/local/etc/nginx/</p>
<p> </p>
<p>Start/ Stop: </p>
<p> sudo brew services start nginx</p>
<p> sudo brew services stop nginx</p>
<p> </p>
<p>If the above do not work/ stubborn process: </p>
<p> </p>
<p>sudo nginx -s quit</p>
<p> </p>
<p>Load/ Unload*:</p>
<p>launchctl unload /usr/local/cellar/nginx/1.17.10/homebrew.mxcl.nginx.plist</p>
<p>launchctl load /usr/local/cellar/nginx/1.17.10/homebrew.mxcl.nginx.plist</p>
<p> </p>
<p> </p>
<p>Test NGINX configuration: </p>
<p>sudo nginx -t</p>
<p></p>
<p></p>
<p>Troubleshooting Process and Research </p>
<p></p>
<p>As we know that this issue involves NGIX failing to redirect to Tomcat properly. One possible solution to address this is to add the following to the NGINX config file: </p>
<p></p>
<p></p>
<p>server {</p>
<p>    listen 80;</p>
<p>    listen [::]:80;</p>
<p>    server_name localhost; </p>
<p></p>
<p>    location / {</p>
<p>            proxy_redirect      off;</p>
<p>            proxy_set_header    X-Real-IP $remote_addr;</p>
<p>            proxy_set_header    X-Forwarded-For $proxy_add_x_forwarded_for;</p>
<p>            proxy_set_header    X-Forwarded-Proto $scheme;</p>
<p>            proxy_set_header    Host $host;</p>
<p>            proxy_pass          tomcatIPaddress; </p>
<p>    }</p>
<p>}</p>
<p></p>
<p></p>
<p>Currently, existing redirects are not specified, which could potentially pose an issue. </p>
<p></p>
<p></p>
<p>The console errors associated with SQUID Web point towards bundle.js, as well as a connection refused error to localhost:8383/CirdlesWebUI. These errors could point to an issue with the proxy server. </p>
<p></p>
<p>Potential further items: </p>
<p>•	Check to see if anything is set up on an address that shouldn’t be. </p>
<p>•	Research configuring using a URI. </p>
<p></p>
<p></p>
<p>As this process continues, a solution should be reached soon. </p>
  
  
  <br>

<h3>Blog Post #1 SQUID Architecture 5.11.2020</h3>
<p>At this time, SQUID’s architecture involves the use of NGINX and Tomcat. Research implemented will explore the possibility of using these same architectures or changing the Servlets entirely. The research process behind this decision is outlined in this blog post. </p>
<p>Currently SQUID uses NGINX on the client-side of the web application, and Tomcat to execute backend functionality. In this case, the use of a reverse proxy servlet keeps utilization centralized. However, the need to create login sessions brings into question what the right steps are to add this functionality. </p>
<p>It is possible to add login functionality and session management to this current architecture. However, there exist other architectures that could be implemented as opposed to the existing servlets. This post will outline the guidelines that will be considered when researching login session capabilities and possible changes to architecture, as well as options that will allow for more robust functionality. </p>
<p>Ideally, changes in architecture that build onto the existing servlets should be considered first. While it is possible to change the architecture of SQUID entirely, there already exists a foundation that can be built upon. The following options have been featured in this post based on the plausibility of their implementation. </p>

<p>Option 1: Store sessions in Redis. </p>
Redis is a data structure store that is typically used as a database, cache, and message broker. Redis stands for remote dictionary server, and in this case, Tomcat would be configured to store its sessions in Redis, and NGIX could still be used as a reverse proxy. Currently this option makes the most sense for adding functionality to SQUID. 

<p>Option 2: Add functionality using Spring Boot. </p>
<p>This option would require that SQUID is reconfigured as a Spring Boot application. This reconfiguring process would involve the creation of a controller package. Due to the implementation of JavaFX, the IDE of choice for the CIRDLES lab is Netbeans. This option would also require the installation and configuration of the Spring Boot plugin for Netbeans, as well. This would also require Spring Boot to be configured into both Tomcat and NGINX. </p>

<p>Option 3: Change the architecture entirely. </p>
<p>While this option is the broadest one. There are several possibilities that could be implemented. As SQUID is written in Java, HTTP Session can be added, and the functionality of Tomcat can be expanded, or a JSP can be used. Other possible architecture solutions include Apache HTTP Server Project, Mongoose, or even Rwasa. 
</p>

</body>
